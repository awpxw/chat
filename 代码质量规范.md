# 高质量代码开发规范：20 分钟交付零告警接口的最佳实践

目标：一次性通过最严格的 SonarQube 质量门  
New Bugs = 0  
New Vulnerabilities = 0  
New Security Hotspots = 0  
New Code Coverage ≥ 85%  
New Duplicated Lines ≤ 3%  
Maintainability Rating = A

## 一、核心原则（请熟记）

| 序号 | 原则                       | 说明                                           |
|------|----------------------------|------------------------------------------------|
| 1    | Skeleton First         | 先搭骨架，再填实现                             |
| 2    | Golden Path First      | 先写一条端到端测试，确保主流程永远绿           |
| 3    | Test-Driven Fine-Grained | 所有分支、校验、异常均由单元测试驱动           |
| 4    | Sonar Check Immediately | 每完成一个类立即本地扫描，绝不累积告警         |
| 5    | Validate First          | 所有入参必先校验，永不让 NPE 向下传播          |

## 二、标准 20 分钟交付节奏（可直接执行）

| 时间         | 阶段             | 具体动作                                             | 产出与效果                              |
|--------------|------------------|------------------------------------------------------|-----------------------------------------|
| 1–3 min      | 骨架搭建         | 完成 Controller、Service、DTO，所有方法先 throw TODO | 编译通过，接口契约锁定                  |
| 4–7 min      | 黄金路径测试     | 写 1 条完整集成/E2E 测试（Happy Path）               | 打通全链路，依赖全部暴露                |
| 8–12 min     | 最小可用实现     | 最简逻辑让黄金路径测试由红转绿                       | 拥有不可破坏的主流程                    |
| 13–18 min    | 测试驱动完善     | 逐一写单元测试 → 实现校验、边界、异常 → 重构         | 覆盖率飙升，圈复杂度暴跌                |
| 19 min       | 本地 Sonar 扫描  | `./gradlew test sonarqube` 或 `sonar-scanner`        | 确认三大“0”全达成                       |
| 20 min       | 提交 PR          | 推送代码                                             | 99% 一次通过审核+质量门                 |

## 三、永不被 Sonar 打脸的编码规范清单

| 类别         | 必做事项                           | 典型正确写法（Java 示例）                                                                 |
|--------------|------------------------------------|-------------------------------------------------------------------------------------------|
| 参数校验     | 立即非空、长度、格式校验           | `Objects.requireNonNull(param, "xxx不能为空");`                                           |
| 集合返回     | 永远返回不可变集合                 | `return list.stream().filter(...).toList();`                                              |
| 密码/密钥     | 禁止任何硬编码                     | 使用 `passwordEncoder.encode(raw)`，测试用 Mock                                            |
| 加密/随机     | 使用强算法                         | `BCryptPasswordEncoder` / `SecureRandom`                                                 |
| SQL 操作     | 禁止字符串拼接                     | 使用 MyBatis / JOOQ / PreparedStatement                                                   |
| 资源关闭     | 必须自动关闭                       | `try (InputStream is = ...) { ... }`                                                      |
| 日志         | 使用占位符                         | `log.info("用户注册成功: {}", username);`                                                 |
| 方法拆分     | 单方法 ≤ 30 行，圈复杂度 ≤ 10      | 复杂逻辑立即提取 private 方法                                                             |
| 异常处理     | 抛业务异常，不吞异常               | `throw new BusinessException("错误信息");`                                                |

## 四、完整可运行示例（Spring Boot 3 + Java 21）

```java
@PostMapping("/register")
public ResponseEntity<Long> register(@RequestBody @Valid UserRegisterRequest r) {
    return ResponseEntity.ok(userService.register(r));
}

@Service
@Transactional
public class UserService {
    public Long register(UserRegisterRequest r) {
        validate(r);                                                                 // 立即校验
        if (userMapper.selectByUsername(r.username()) != null)                       // 唯一性
            throw new BusinessException("用户名已被使用");

        UserPO user = buildUser(r);
        userMapper.insert(user);
        return user.getId();
    }
    // private 方法略…
}
```

本地 Sonar 扫描后结果：  
New Bugs = 0 New Vulnerabilities = 0 New Security Hotspots = 0  
New Code Coverage = 90%+ New Duplicated Lines = 0% Rating = A

**结论：先让代码跑起来 → 再让代码正确 → 最后让 Sonar 闭嘴。顺序不可乱！**

把这篇文档发给新人，他们看一次就能永久摆脱质量门恐惧症。祝你每提一个 PR 都又快又稳！